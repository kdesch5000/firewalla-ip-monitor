<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firewalla WAN Connection Monitor</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        
        .header {
            background-color: #2d2d2d;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .header-main h1 {
            margin: 0;
            color: #00ff88;
            font-size: 1.5rem;
        }
        
        .header-main .subtitle {
            margin: 0.5rem 0 0 0;
            color: #cccccc;
            font-size: 0.9rem;
        }
        
        .header-stats {
            display: flex;
            gap: 2rem;
            align-items: center;
        }
        
        .stat-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 100px;
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: #999999;
            margin-bottom: 0.2rem;
        }
        
        .stat-value {
            font-size: 1rem;
            color: #00ff88;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .header-stats {
                width: 100%;
                justify-content: space-around;
            }
        }
        
        .controls {
            background-color: #333333;
            padding: 1rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .btn {
            background-color: #0066cc;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .btn:hover {
            background-color: #0052a3;
        }
        
        .btn:disabled {
            background-color: #666666;
            cursor: not-allowed;
        }
        
        .btn.active {
            background-color: #00ff88;
            color: #000000;
        }
        
        .status {
            color: #cccccc;
            font-size: 0.9rem;
        }
        
        .stats {
            display: flex;
            gap: 2rem;
            color: #00ff88;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-number {
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #cccccc;
        }
        
        #map {
            height: calc(100vh - 140px);
            background-color: #1a1a1a;
        }
        
        .connection-popup {
            background-color: #2d2d2d;
            color: #ffffff;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .connection-popup h3 {
            margin: 0 0 0.5rem 0;
            color: #00ff88;
        }
        
        .connection-popup .detail {
            margin: 0.25rem 0;
        }
        
        .connection-popup .label {
            font-weight: bold;
            color: #cccccc;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 2rem;
            border-radius: 8px;
            text-align: center;
        }
        
        .spinner {
            border: 4px solid #333333;
            border-top: 4px solid #00ff88;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            background-color: #ff4444;
            color: white;
            padding: 1rem;
            margin: 1rem;
            border-radius: 4px;
            text-align: center;
        }
        
        /* Connections List Styles */
        #connectionsList {
            display: none;
            height: calc(100vh - 140px);
            overflow-y: auto;
            background-color: #1a1a1a;
            padding: 1rem;
        }
        
        .connections-table {
            width: 100%;
            border-collapse: collapse;
            background-color: #2d2d2d;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .connections-table th {
            background-color: #333333;
            color: #00ff88;
            padding: 1rem;
            text-align: left;
            font-weight: bold;
            border-bottom: 2px solid #00ff88;
        }
        
        .connections-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #444444;
            color: #ffffff;
        }
        
        .connections-table tr:hover {
            background-color: #3d3d3d;
        }
        
        .connections-table .ip-cell {
            font-family: 'Courier New', monospace;
            color: #00ccff;
        }
        
        .connections-table .hostname-cell {
            color: #ffaa00;
            font-size: 0.9rem;
        }
        
        .connections-table .location-cell {
            color: #cccccc;
        }
        
        .connections-table .count-cell {
            text-align: center;
            font-weight: bold;
            color: #00ff88;
        }
        
        .connections-table .date-cell {
            font-size: 0.9rem;
            color: #999999;
        }
        
        .flag-icon {
            width: 20px;
            height: auto;
            margin-right: 0.5rem;
            vertical-align: middle;
        }
        
        .search-box {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            background-color: #333333;
            border: 1px solid #555555;
            border-radius: 4px;
            color: #ffffff;
            font-size: 1rem;
        }
        
        .search-box::placeholder {
            color: #999999;
        }
        
        .table-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .sort-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .sort-btn {
            background-color: #444444;
            color: #cccccc;
            border: none;
            padding: 0.5rem 0.75rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .sort-btn:hover {
            background-color: #555555;
        }
        
        .sort-btn.active {
            background-color: #0066cc;
            color: white;
        }
        
        /* Connection line animation */
        @keyframes dash {
            to {
                stroke-dashoffset: -20;
            }
        }
        
        .connection-arc {
            pointer-events: none;
        }
        
        /* Color Legend Styles */
        .color-legend {
            background-color: #2d2d2d;
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 2rem;
            border-bottom: 1px solid #444444;
        }
        
        .legend-title {
            color: #cccccc;
            font-size: 0.9rem;
            font-weight: bold;
            margin-right: 0.5rem;
        }
        
        .legend-items {
            display: flex;
            gap: 1.5rem;
            align-items: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-line {
            width: 30px;
            height: 3px;
            border-radius: 1px;
        }
        
        .legend-line.high {
            background-color: #ff4444;
            height: 4px;
        }
        
        .legend-line.medium {
            background-color: #ffaa00;
            height: 3px;
        }
        
        .legend-line.low {
            background-color: #00ff88;
            height: 2px;
        }
        
        .legend-text {
            color: #ffffff;
            font-size: 0.85rem;
        }
        
        .legend-count {
            color: #999999;
            font-size: 0.75rem;
        }
        
        /* Database Stats Styles */
        .legend-divider {
            width: 1px;
            height: 30px;
            background-color: #555555;
        }
        
        .database-stats {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .db-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .db-stat {
            color: #cccccc;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .db-value {
            color: #00ff88;
            font-weight: bold;
        }
        
        /* Pagination Styles */
        .pagination-controls {
            background-color: #333333;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #444444;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .pagination-info {
            color: #cccccc;
            font-size: 0.9rem;
        }
        
        .pagination-settings {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .page-size-select {
            background-color: #444444;
            color: #ffffff;
            border: 1px solid #555555;
            padding: 0.25rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .pagination-buttons {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .pagination-btn {
            background-color: #0066cc;
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background-color 0.2s;
        }
        
        .pagination-btn:hover:not(:disabled) {
            background-color: #0080ff;
        }
        
        .pagination-btn:disabled {
            background-color: #555555;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .page-jump {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .page-jump-input {
            width: 60px;
            background-color: #444444;
            color: #ffffff;
            border: 1px solid #555555;
            padding: 0.25rem;
            border-radius: 4px;
            text-align: center;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .pagination-controls {
                flex-direction: column;
                align-items: stretch;
                text-align: center;
            }
            
            .pagination-buttons {
                justify-content: center;
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-main">
            <h1>🌐 Firewalla WAN Connection Monitor</h1>
            <div class="subtitle">Real-time visualization of external IP connections to your network</div>
        </div>
        <div class="header-stats">
            <div class="stat-group">
                <div class="stat-item">
                    <span class="stat-label">Database Size</span>
                    <span class="stat-value" id="headerDbSize">--</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Oldest Record</span>
                    <span class="stat-value" id="headerOldestRecord">--</span>
                </div>
            </div>
            <div class="stat-group">
                <div class="stat-item">
                    <span class="stat-label">Total Connections</span>
                    <span class="stat-value" id="headerTotalConnections">--</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Unique IPs</span>
                    <span class="stat-value" id="headerUniqueIPs">--</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button id="refreshBtn" class="btn">🔄 Refresh Data</button>
        <button id="mapViewBtn" class="btn active">🗺️ Map View</button>
        <button id="listViewBtn" class="btn">📋 Connections List</button>
        
        <div style="border-left: 2px solid #555; padding-left: 1rem; margin-left: 1rem;">
            <span style="color: #cccccc; font-size: 0.9rem; margin-right: 0.5rem;">Direction:</span>
            <button id="directionBothBtn" class="btn active">🔄 Both</button>
            <button id="directionInboundBtn" class="btn">⬇️ Inbound</button>
            <button id="directionOutboundBtn" class="btn">⬆️ Outbound</button>
        </div>
        
        <div style="border-left: 2px solid #555; padding-left: 1rem; margin-left: 1rem;">
            <span style="color: #cccccc; font-size: 0.9rem; margin-right: 0.5rem;">Time Range:</span>
            <button id="timeCurrentBtn" class="btn active">📊 Current</button>
            <button id="timeHistoryBtn" class="btn">📜 History</button>
            <input type="datetime-local" id="startDateTime" style="display: none; margin-left: 0.5rem; padding: 0.25rem;">
            <input type="datetime-local" id="endDateTime" style="display: none; margin-left: 0.5rem; padding: 0.25rem;">
            <button id="applyTimeFilter" class="btn" style="display: none;">Apply</button>
        </div>
        
        <div class="status" id="status">Loading...</div>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-number" id="connectionCount">-</div>
                <div class="stat-label">Connections</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="lastUpdate">-</div>
                <div class="stat-label">Last Update</div>
            </div>
        </div>
    </div>
    
    <!-- Color Legend -->
    <div id="colorLegend" class="color-legend" style="display: none;">
        <div class="legend-title">📊 Connection Volume:</div>
        <div class="legend-items">
            <div class="legend-item">
                <div class="legend-line high"></div>
                <span class="legend-text">High <span class="legend-count">(>50)</span></span>
            </div>
            <div class="legend-item">
                <div class="legend-line medium"></div>
                <span class="legend-text">Medium <span class="legend-count">(21-50)</span></span>
            </div>
            <div class="legend-item">
                <div class="legend-line low"></div>
                <span class="legend-text">Low <span class="legend-count">(1-20)</span></span>
            </div>
        </div>
        <div style="margin-left: auto; color: #999999; font-size: 0.8rem;">
            Line color and thickness indicate total connection count from each IP
        </div>
    </div>
    
    <div id="map"></div>
    
    <div id="connectionsList">
        <div class="table-controls">
            <div style="display: flex; gap: 1rem; align-items: center; flex: 1;">
                <input type="text" id="searchBox" class="search-box" placeholder="🔍 Search by IP, hostname, city, country, or ISP..." style="flex: 1;">
                <button id="downloadCsvBtn" class="btn" style="white-space: nowrap;">📥 Download CSV</button>
            </div>
            <div class="sort-controls">
                <span style="color: #cccccc; font-size: 0.9rem;">Sort by:</span>
                <button class="sort-btn active" data-sort="connectionCount">Total</button>
                <button class="sort-btn" data-sort="inboundCount">Inbound</button>
                <button class="sort-btn" data-sort="outboundCount">Outbound</button>
                <button class="sort-btn" data-sort="lastSeen">Last Seen</button>
                <button class="sort-btn" data-sort="country">Country</button>
                <button class="sort-btn" data-sort="ip">IP Address</button>
            </div>
        </div>
        
        <table class="connections-table">
            <thead>
                <tr>
                    <th>IP Address</th>
                    <th>Hostname</th>
                    <th>Location</th>
                    <th>ISP / Organization</th>
                    <th>Connections</th>
                    <th>Direction</th>
                    <th>Last Seen</th>
                </tr>
            </thead>
            <tbody id="connectionsTableBody">
                <!-- Table rows will be populated by JavaScript -->
            </tbody>
        </table>
        
        <div class="pagination-controls">
            <div class="pagination-info">
                <span id="paginationInfo">Showing -- of --</span>
            </div>
            <div class="pagination-settings">
                <span style="color: #cccccc; font-size: 0.9rem;">Show:</span>
                <select id="pageSizeSelect" class="page-size-select">
                    <option value="20" selected>20</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="200">200</option>
                </select>
                <span style="color: #cccccc; font-size: 0.9rem;">per page</span>
            </div>
            <div class="pagination-buttons">
                <button id="firstPageBtn" class="pagination-btn" disabled>⏪ First</button>
                <button id="prevPageBtn" class="pagination-btn" disabled>◀ Previous</button>
                <div class="page-jump">
                    <span style="color: #cccccc; font-size: 0.9rem;">Page:</span>
                    <input type="number" id="pageJumpInput" class="page-jump-input" value="1" min="1">
                    <span id="totalPagesSpan" style="color: #cccccc; font-size: 0.9rem;">of --</span>
                </div>
                <button id="nextPageBtn" class="pagination-btn" disabled>Next ▶</button>
                <button id="lastPageBtn" class="pagination-btn" disabled>Last ⏩</button>
            </div>
        </div>
    </div>
    
    <div id="loading" class="loading" style="display: none;">
        <div class="spinner"></div>
        <div>Loading connection data...</div>
    </div>
    
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Global variables
        let map;
        let markers = [];
        let connectionLines = [];
        let homeMarker = null;
        let connectionsData = [];
        let filteredData = [];
        let homeLocation = null;
        let currentView = 'map';
        let sortField = 'connectionCount';
        let sortDirection = 'desc';
        let directionFilter = 'both'; // 'both', 'inbound', 'outbound'
        let timeMode = 'current'; // 'current', 'history'
        let startDateTime = null;
        let endDateTime = null;
        
        // Pagination variables
        let currentPage = 1;
        let pageSize = 20;
        let totalRows = 0;
        let totalPages = 0;
        
        // Initialize map
        function initMap() {
            map = L.map('map').setView([39.8283, -98.5795], 4); // Center on USA
            
            // Dark theme tile layer
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '© OpenStreetMap contributors © CARTO',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);
        }
        
        // Calculate arc points for curved line between two coordinates
        function calculateArcPoints(start, end, numPoints = 100) {
            const points = [];
            const lat1 = start[0] * Math.PI / 180;
            const lon1 = start[1] * Math.PI / 180;
            const lat2 = end[0] * Math.PI / 180;
            const lon2 = end[1] * Math.PI / 180;
            
            // Calculate distance and bearing
            const dLon = lon2 - lon1;
            const a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(dLon);
            const distance = Math.acos(Math.min(1, a));
            
            if (distance < 0.01) { // Too close, draw straight line
                for (let i = 0; i <= numPoints; i++) {
                    const fraction = i / numPoints;
                    const lat = start[0] + (end[0] - start[0]) * fraction;
                    const lon = start[1] + (end[1] - start[1]) * fraction;
                    points.push([lat, lon]);
                }
                return points;
            }
            
            // Create arc points
            for (let i = 0; i <= numPoints; i++) {
                const fraction = i / numPoints;
                const A = Math.sin((1 - fraction) * distance) / Math.sin(distance);
                const B = Math.sin(fraction * distance) / Math.sin(distance);
                
                const x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);
                const y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);
                const z = A * Math.sin(lat1) + B * Math.sin(lat2);
                
                const lat = Math.atan2(z, Math.sqrt(x * x + y * y)) * 180 / Math.PI;
                const lon = Math.atan2(y, x) * 180 / Math.PI;
                
                // Add curvature by adjusting altitude simulation
                const curveFactor = Math.sin(fraction * Math.PI) * 0.3;
                const adjustedLat = lat + curveFactor * Math.abs(end[0] - start[0]);
                
                points.push([adjustedLat, lon]);
            }
            
            return points;
        }
        
        // Clear existing markers and lines
        function clearMarkers() {
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
        }
        
        // Clear connection lines
        function clearConnectionLines() {
            connectionLines.forEach(line => map.removeLayer(line));
            connectionLines = [];
        }
        
        // Add home marker (Chicago)
        function addHomeMarker() {
            if (homeLocation && homeMarker) {
                map.removeLayer(homeMarker);
            }
            
            if (homeLocation) {
                homeMarker = L.circleMarker([homeLocation.latitude, homeLocation.longitude], {
                    radius: 12,
                    fillColor: '#ff0066',
                    color: '#ffffff',
                    weight: 3,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map);
                
                homeMarker.bindPopup(`
                    <div class="connection-popup">
                        <h3>🏠 Home Location</h3>
                        <div class="detail"><span class="label">Location:</span> ${homeLocation.city}, ${homeLocation.region}</div>
                        <div class="detail"><span class="label">Country:</span> ${homeLocation.country}</div>
                        <div class="detail"><span class="label">WAN Interface:</span> mrfish.ooguy.com</div>
                    </div>
                `);
            }
        }
        
        // Add markers for connections
        function addConnectionMarkers(connections) {
            clearMarkers();
            clearConnectionLines();
            
            // Add home marker first
            addHomeMarker();
            
            connections.forEach(connection => {
                if (connection.latitude && connection.longitude) {
                    // Create custom icon based on connection count
                    const size = Math.min(Math.max(connection.connectionCount / 5 + 10, 10), 30);
                    const color = connection.connectionCount > 50 ? '#ff4444' : 
                                 connection.connectionCount > 20 ? '#ffaa00' : '#00ff88';
                    
                    const marker = L.circleMarker([connection.latitude, connection.longitude], {
                        radius: size / 2,
                        fillColor: color,
                        color: '#ffffff',
                        weight: 2,
                        opacity: 0.8,
                        fillOpacity: 0.6
                    }).addTo(map);
                    
                    // Create popup content
                    const popupContent = `
                        <div class="connection-popup">
                            <h3>${connection.ip}</h3>
                            <div class="detail"><span class="label">Location:</span> ${connection.city}, ${connection.region}, ${connection.country}</div>
                            <div class="detail"><span class="label">ISP:</span> ${connection.isp || 'Unknown'}</div>
                            <div class="detail"><span class="label">Organization:</span> ${connection.org || 'Unknown'}</div>
                            <div class="detail"><span class="label">ASN:</span> ${connection.asn || 'Unknown'}</div>
                            <div class="detail"><span class="label">Connections:</span> ${connection.connectionCount} total</div>
                            <div class="detail"><span class="label">Inbound:</span> ${connection.inboundCount || 0} | <span class="label">Outbound:</span> ${connection.outboundCount || 0}</div>
                            <div class="detail"><span class="label">Last Seen:</span> ${new Date(connection.lastSeen).toLocaleString()}</div>
                            <div class="detail"><span class="label">Timezone:</span> ${connection.timezone || 'Unknown'}</div>
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                    markers.push(marker);
                    
                    // Draw arched line to home location if available
                    if (homeLocation) {
                        const connectionPoint = [connection.latitude, connection.longitude];
                        const homePoint = [homeLocation.latitude, homeLocation.longitude];
                        
                        // Calculate arc points
                        const arcPoints = calculateArcPoints(connectionPoint, homePoint, 50);
                        
                        // Create polyline with gradient effect
                        const lineColor = connection.connectionCount > 50 ? '#ff4444' : 
                                         connection.connectionCount > 20 ? '#ffaa00' : '#00ff88';
                        
                        const connectionLine = L.polyline(arcPoints, {
                            color: lineColor,
                            weight: Math.min(connection.connectionCount / 10 + 1, 4),
                            opacity: 0.6,
                            smoothFactor: 1,
                            className: 'connection-arc'
                        }).addTo(map);
                        
                        connectionLines.push(connectionLine);
                        
                        // Add animation class for visual effect
                        setTimeout(() => {
                            if (connectionLine._path) {
                                connectionLine._path.style.strokeDasharray = '10,10';
                                connectionLine._path.style.animation = 'dash 2s linear infinite';
                            }
                        }, 100);
                    }
                }
            });
        }
        
        // Switch between map and list views
        function switchView(view) {
            currentView = view;
            
            if (view === 'map') {
                document.getElementById('map').style.display = 'block';
                document.getElementById('connectionsList').style.display = 'none';
                document.getElementById('colorLegend').style.display = 'flex';
                document.getElementById('mapViewBtn').classList.add('active');
                document.getElementById('listViewBtn').classList.remove('active');
                
                // Trigger map resize in case it was hidden
                if (map) {
                    setTimeout(() => map.invalidateSize(), 100);
                }
            } else {
                document.getElementById('map').style.display = 'none';
                document.getElementById('connectionsList').style.display = 'block';
                document.getElementById('colorLegend').style.display = 'none';
                document.getElementById('mapViewBtn').classList.remove('active');
                document.getElementById('listViewBtn').classList.add('active');
                
                // Populate the table
                populateConnectionsTable();
            }
        }
        
        // Cache for resolved hostnames to avoid repeated API calls
        const hostnameCache = new Map();
        
        // Resolve hostname using server-side DNS lookup
        async function resolveHostname(ip) {
            // Check cache first
            if (hostnameCache.has(ip)) {
                return hostnameCache.get(ip);
            }
            
            try {
                const response = await fetch(`/api/hostname/${ip}`);
                const data = await response.json();
                
                if (data.hostname) {
                    hostnameCache.set(ip, data.hostname);
                    return data.hostname;
                }
            } catch (error) {
                console.log(`Server-side hostname resolution failed for ${ip}:`, error);
            }
            
            const result = 'No hostname found';
            hostnameCache.set(ip, result);
            return result;
        }
        
        // Update pagination UI elements
        function updatePaginationUI() {
            // Update pagination info
            const startRecord = totalRows === 0 ? 0 : (currentPage - 1) * pageSize + 1;
            const endRecord = Math.min(currentPage * pageSize, totalRows);
            document.getElementById('paginationInfo').textContent = 
                `Showing ${startRecord}-${endRecord} of ${totalRows.toLocaleString()}`;
            
            // Update total pages
            document.getElementById('totalPagesSpan').textContent = `of ${totalPages.toLocaleString()}`;
            
            // Update page jump input
            const pageJumpInput = document.getElementById('pageJumpInput');
            pageJumpInput.value = currentPage;
            pageJumpInput.max = totalPages;
            
            // Update button states
            document.getElementById('firstPageBtn').disabled = currentPage === 1 || totalPages === 0;
            document.getElementById('prevPageBtn').disabled = currentPage === 1 || totalPages === 0;
            document.getElementById('nextPageBtn').disabled = currentPage === totalPages || totalPages === 0;
            document.getElementById('lastPageBtn').disabled = currentPage === totalPages || totalPages === 0;
        }
        
        // Navigate to specific page
        function goToPage(page) {
            const newPage = Math.max(1, Math.min(page, totalPages));
            if (newPage !== currentPage) {
                currentPage = newPage;
                populateConnectionsTable();
            }
        }
        
        // Populate connections table with pagination
        async function populateConnectionsTable() {
            // Sort the data first
            const sortedData = [...filteredData].sort((a, b) => {
                let aVal = a[sortField];
                let bVal = b[sortField];
                
                if (sortField === 'connectionCount' || sortField === 'inboundCount' || sortField === 'outboundCount') {
                    return sortDirection === 'desc' ? bVal - aVal : aVal - bVal;
                } else if (sortField === 'lastSeen') {
                    return sortDirection === 'desc' ? 
                        new Date(bVal) - new Date(aVal) : 
                        new Date(aVal) - new Date(bVal);
                } else {
                    if (typeof aVal === 'string') aVal = aVal.toLowerCase();
                    if (typeof bVal === 'string') bVal = bVal.toLowerCase();
                    if (sortDirection === 'desc') {
                        return bVal > aVal ? 1 : bVal < aVal ? -1 : 0;
                    } else {
                        return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                    }
                }
            });
            
            // Update pagination info
            totalRows = sortedData.length;
            totalPages = Math.ceil(totalRows / pageSize);
            
            // Ensure current page is valid
            if (currentPage > totalPages && totalPages > 0) {
                currentPage = totalPages;
            } else if (currentPage < 1) {
                currentPage = 1;
            }
            
            // Calculate pagination slice
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = Math.min(startIndex + pageSize, totalRows);
            const pageData = sortedData.slice(startIndex, endIndex);
            
            // Update pagination UI
            updatePaginationUI();
            
            // Populate table with current page data
            const tableBody = document.getElementById('connectionsTableBody');
            tableBody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #999;">Loading hostnames...</td></tr>';
            tableBody.innerHTML = '';
            
            // Process each connection with hostname resolution
            for (const connection of pageData) {
                const row = document.createElement('tr');
                
                // Use hostname from server data if available, otherwise resolve
                const hostname = connection.hostname && connection.hostname !== 'No hostname found' 
                    ? connection.hostname 
                    : await Promise.race([
                        resolveHostname(connection.ip),
                        new Promise(resolve => setTimeout(() => resolve('Resolving...'), 2000))
                    ]);
                
                row.innerHTML = `
                    <td class="ip-cell">${connection.ip}</td>
                    <td class="hostname-cell">${hostname}</td>
                    <td class="location-cell">
                        <img src="https://flagsapi.com/${connection.countryCode}/flat/32.png" 
                             class="flag-icon" alt="${connection.countryCode}" 
                             onerror="this.style.display='none'">
                        ${connection.city}, ${connection.region}<br>
                        <small>${connection.country}</small>
                    </td>
                    <td class="location-cell">
                        <strong>${connection.isp || 'Unknown ISP'}</strong><br>
                        <small>${connection.org || 'Unknown Org'}</small><br>
                        <small style="color: #666;">${connection.asn || 'Unknown ASN'}</small>
                    </td>
                    <td class="count-cell">${connection.connectionCount}</td>
                    <td class="count-cell">
                        <span style="color: #ff6666;">⬇️ ${connection.inboundCount || 0}</span><br>
                        <span style="color: #66ff66;">⬆️ ${connection.outboundCount || 0}</span>
                    </td>
                    <td class="date-cell">${new Date(connection.lastSeen).toLocaleString()}</td>
                `;
                
                tableBody.appendChild(row);
            }
        }
        
        // Filter connections based on search
        function filterConnections(searchTerm = '') {
            // Start with all connections
            let filtered = [...connectionsData];
            
            // Apply search term filter
            if (searchTerm) {
                const term = searchTerm.toLowerCase();
                filtered = filtered.filter(conn => 
                    conn.ip.toLowerCase().includes(term) ||
                    (conn.city && conn.city.toLowerCase().includes(term)) ||
                    (conn.region && conn.region.toLowerCase().includes(term)) ||
                    (conn.country && conn.country.toLowerCase().includes(term)) ||
                    (conn.isp && conn.isp.toLowerCase().includes(term)) ||
                    (conn.org && conn.org.toLowerCase().includes(term))
                );
            }
            
            // Apply direction filter
            if (directionFilter !== 'both') {
                filtered = filtered.filter(conn => {
                    if (directionFilter === 'inbound') {
                        return conn.inboundCount > 0;
                    } else if (directionFilter === 'outbound') {
                        return conn.outboundCount > 0;
                    }
                    return true;
                });
            }
            
            filteredData = filtered;
            
            // Update the display
            if (currentView === 'map') {
                addConnectionMarkers(filteredData);
            } else {
                populateConnectionsTable();
            }
        }
        
        // Load connections data based on current mode
        async function loadConnectionData() {
            if (timeMode === 'current') {
                await loadCurrentConnections();
            } else {
                await loadHistoricalConnections();
            }
        }
        
        // Load current connections (aggregated by IP)
        async function loadCurrentConnections() {
            try {
                document.getElementById('loading').style.display = 'block';
                
                const response = await fetch('/api/connections');
                const data = await response.json();
                
                await processConnectionData(data, 'current');
                
            } catch (error) {
                console.error('Error loading current connections:', error);
                document.getElementById('status').textContent = 'Error loading current connections';
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Load historical connections (fast database version)
        async function loadHistoricalConnections() {
            try {
                document.getElementById('loading').style.display = 'block';
                
                // Try fast database endpoint first
                let url = '/api/connections/history-fast?limit=2000';
                
                if (startDateTime) {
                    url += `&startDate=${encodeURIComponent(startDateTime)}`;
                }
                
                if (endDateTime) {
                    url += `&endDate=${encodeURIComponent(endDateTime)}`;
                }
                
                if (directionFilter !== 'both') {
                    url += `&direction=${encodeURIComponent(directionFilter)}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                // Check if we got database results (fast) or fall back to JSON processing
                if (data.source === 'database') {
                    // Database returns aggregated data like current connections
                    await processConnectionData(data, 'current');
                } else {
                    // Fallback to JSON processing
                    await processConnectionData(data, 'history');
                }
                
            } catch (error) {
                console.error('Error loading historical connections:', error);
                document.getElementById('status').textContent = 'Error loading historical connections';
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Process connection data for display
        async function processConnectionData(data, mode) {
            if (mode === 'current') {
                connectionsData = data.connections;
                filteredData = [...connectionsData]; 
                homeLocation = data.homeLocation;
                
                // Update UI
                document.getElementById('connectionCount').textContent = data.totalConnections;
                document.getElementById('lastUpdate').textContent = new Date(data.lastUpdate).toLocaleString();
                document.getElementById('status').textContent = `Loaded ${data.totalConnections} current connections`;
            } else {
                // For historical data, aggregate by IP address like current mode
                const ipMap = new Map();
                data.connections.forEach(conn => {
                    const ip = conn.ip;
                    if (!ipMap.has(ip)) {
                        ipMap.set(ip, {
                            ip: ip,
                            connectionCount: 0,
                            inboundCount: 0,
                            outboundCount: 0,
                            lastSeen: conn.timestamp,
                            connectionTypes: new Set(),
                            directions: new Set(),
                            details: []
                        });
                    }
                    
                    const existing = ipMap.get(ip);
                    existing.connectionCount++;
                    
                    if (conn.direction === 'inbound') {
                        existing.inboundCount++;
                    } else if (conn.direction === 'outbound') {
                        existing.outboundCount++;
                    }
                    
                    existing.connectionTypes.add(conn.type);
                    existing.directions.add(conn.direction);
                    existing.details.push(conn.details);
                    
                    // Keep the most recent timestamp
                    if (new Date(conn.timestamp) > new Date(existing.lastSeen)) {
                        existing.lastSeen = conn.timestamp;
                    }
                });
                
                // Convert to array and add default geolocation values
                connectionsData = Array.from(ipMap.values()).map(conn => ({
                    ...conn,
                    connectionTypes: Array.from(conn.connectionTypes),
                    directions: Array.from(conn.directions),
                    // Add default geolocation data for historical connections
                    latitude: 0, // Will be resolved via geolocation lookup
                    longitude: 0,
                    country: 'Unknown',
                    countryCode: 'XX',
                    city: 'Unknown',
                    region: 'Unknown',
                    timezone: 'Unknown',
                    isp: 'Unknown',
                    org: 'Unknown',
                    asn: 'Unknown',
                    hostname: 'No hostname found'
                }));
                
                filteredData = [...connectionsData];
                
                // First try to get location data from current connections if available
                await tryPopulateFromCurrentData();
                
                // Then resolve remaining geolocation for historical IPs
                await resolveHistoricalGeolocation();
                
                // Update UI
                document.getElementById('connectionCount').textContent = connectionsData.length;
                document.getElementById('lastUpdate').textContent = 'Historical Data';
                document.getElementById('status').textContent = `Loaded ${connectionsData.length} unique IPs from ${data.totalCount} historical connections`;
            }
            
            // Apply initial filtering and add markers to map
            filterConnections();
            
            // Fit map to show all markers if we have connections
            if (filteredData.length > 0 && currentView === 'map') {
                const group = new L.featureGroup(markers);
                if (group.getBounds().isValid()) {
                    map.fitBounds(group.getBounds().pad(0.1));
                }
            }
        }
        
        // Try to populate historical connection location data from current connections cache
        async function tryPopulateFromCurrentData() {
            try {
                const currentResponse = await fetch('/api/connections');
                const currentData = await currentResponse.json();
                
                if (currentData.connections) {
                    // Create a lookup map of current connection locations
                    const locationMap = new Map();
                    currentData.connections.forEach(conn => {
                        if (conn.latitude && conn.longitude) {
                            locationMap.set(conn.ip, {
                                latitude: conn.latitude,
                                longitude: conn.longitude,
                                country: conn.country,
                                countryCode: conn.countryCode,
                                city: conn.city,
                                region: conn.region,
                                timezone: conn.timezone,
                                isp: conn.isp,
                                org: conn.org,
                                asn: conn.asn
                            });
                        }
                    });
                    
                    // Update historical connections with current location data
                    connectionsData.forEach(conn => {
                        if (conn.latitude === 0 && conn.longitude === 0) {
                            const location = locationMap.get(conn.ip);
                            if (location) {
                                Object.assign(conn, location);
                            }
                        }
                    });
                    
                    console.log(`Populated ${locationMap.size} historical connections with current location data`);
                }
            } catch (error) {
                console.warn('Failed to populate from current data:', error);
            }
        }
        
        // Resolve geolocation for historical connections with rate limiting handling
        async function resolveHistoricalGeolocation() {
            // Process connections in smaller batches to avoid rate limiting
            const batchSize = 5;
            const connections = connectionsData.filter(conn => conn.latitude === 0 && conn.longitude === 0);
            
            for (let i = 0; i < connections.length; i += batchSize) {
                const batch = connections.slice(i, i + batchSize);
                
                const promises = batch.map(async (conn) => {
                    try {
                        const response = await fetch(`/api/location/${conn.ip}`);
                        const locationData = await response.json();
                        
                        if (locationData && !locationData.error && locationData.latitude && locationData.longitude) {
                            conn.latitude = locationData.latitude;
                            conn.longitude = locationData.longitude;
                            conn.country = locationData.country || 'Unknown';
                            conn.countryCode = locationData.countryCode || 'XX';
                            conn.city = locationData.city || 'Unknown';
                            conn.region = locationData.region || 'Unknown';
                            conn.timezone = locationData.timezone || 'Unknown';
                            conn.isp = locationData.isp || 'Unknown';
                            conn.org = locationData.org || 'Unknown';
                            conn.asn = locationData.asn || 'Unknown';
                        } else {
                            // If geolocation fails, keep the connection but mark it as unlocated
                            console.warn(`Location lookup failed for ${conn.ip}`);
                        }
                    } catch (error) {
                        console.warn(`Failed to resolve location for ${conn.ip}:`, error);
                    }
                });
                
                // Wait for batch to complete
                await Promise.allSettled(promises);
                
                // Add delay between batches to avoid rate limiting
                if (i + batchSize < connections.length) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                // Update display after each batch
                if (currentView === 'map') {
                    addConnectionMarkers(filteredData);
                } else {
                    populateConnectionsTable();
                }
            }
        }
        
        // Legacy function name for compatibility
        async function loadConnections() {
            await loadConnectionData();
            await loadHeaderStats();
        }
        
        // Refresh data
        async function refreshData() {
            const btn = document.getElementById('refreshBtn');
            btn.disabled = true;
            btn.textContent = '🔄 Refreshing...';
            
            try {
                const response = await fetch('/api/refresh', { method: 'POST' });
                const result = await response.json();
                
                document.getElementById('status').textContent = 'Data refresh initiated...';
                
                // Reload connections after a delay
                setTimeout(loadConnections, 3000);
                
            } catch (error) {
                console.error('Error refreshing data:', error);
                document.getElementById('status').textContent = 'Error refreshing data';
            } finally {
                setTimeout(() => {
                    btn.disabled = false;
                    btn.textContent = '🔄 Refresh Data';
                }, 5000);
            }
        }
        
        // Load database statistics for header
        async function loadHeaderStats() {
            try {
                const response = await fetch('/api/stats');
                const stats = await response.json();
                
                // Update database size
                const dbSizeElement = document.getElementById('headerDbSize');
                if (stats.database && stats.database.size_mb) {
                    dbSizeElement.textContent = `${Math.round(stats.database.size_mb)}MB`;
                } else {
                    dbSizeElement.textContent = 'Unknown';
                }
                
                // Update oldest record date
                const oldestElement = document.getElementById('headerOldestRecord');
                if (stats.database && stats.database.oldest_record) {
                    const oldestDate = new Date(stats.database.oldest_record);
                    const now = new Date();
                    const daysDiff = Math.floor((now - oldestDate) / (1000 * 60 * 60 * 24));
                    
                    if (daysDiff === 0) {
                        oldestElement.textContent = 'Today';
                    } else if (daysDiff === 1) {
                        oldestElement.textContent = '1 day ago';
                    } else {
                        oldestElement.textContent = `${daysDiff} days ago`;
                    }
                } else {
                    oldestElement.textContent = 'Unknown';
                }
                
                // Update total connections
                const totalConnectionsElement = document.getElementById('headerTotalConnections');
                if (stats.database && stats.database.total_connections) {
                    const count = stats.database.total_connections;
                    totalConnectionsElement.textContent = count.toLocaleString();
                } else {
                    totalConnectionsElement.textContent = 'Unknown';
                }
                
                // Update unique IPs
                const uniqueIPsElement = document.getElementById('headerUniqueIPs');
                if (stats.database && stats.database.unique_ips) {
                    uniqueIPsElement.textContent = stats.database.unique_ips.toLocaleString();
                } else {
                    uniqueIPsElement.textContent = 'Unknown';
                }
                
            } catch (error) {
                console.error('Error loading header stats:', error);
                document.getElementById('headerDbSize').textContent = 'Error';
                document.getElementById('headerOldestRecord').textContent = 'Error';
                document.getElementById('headerTotalConnections').textContent = 'Error';
                document.getElementById('headerUniqueIPs').textContent = 'Error';
            }
        }
        
        // Update table view
        function updateTable() {
            if (currentView === 'list') {
                populateConnectionsTable();
            }
        }
        
        // Set direction filter
        function setDirectionFilter(direction) {
            directionFilter = direction;
            
            // Update button states
            document.getElementById('directionBothBtn').classList.remove('active');
            document.getElementById('directionInboundBtn').classList.remove('active');
            document.getElementById('directionOutboundBtn').classList.remove('active');
            
            if (direction === 'both') {
                document.getElementById('directionBothBtn').classList.add('active');
            } else if (direction === 'inbound') {
                document.getElementById('directionInboundBtn').classList.add('active');
            } else if (direction === 'outbound') {
                document.getElementById('directionOutboundBtn').classList.add('active');
            }
            
            // Apply the filter
            loadConnectionData();
        }
        
        // Set time mode filter
        function setTimeMode(mode) {
            timeMode = mode;
            
            // Update button states
            document.getElementById('timeCurrentBtn').classList.remove('active');
            document.getElementById('timeHistoryBtn').classList.remove('active');
            
            if (mode === 'current') {
                document.getElementById('timeCurrentBtn').classList.add('active');
                document.getElementById('startDateTime').style.display = 'none';
                document.getElementById('endDateTime').style.display = 'none';
                document.getElementById('applyTimeFilter').style.display = 'none';
            } else if (mode === 'history') {
                document.getElementById('timeHistoryBtn').classList.add('active');
                document.getElementById('startDateTime').style.display = 'inline';
                document.getElementById('endDateTime').style.display = 'inline';
                document.getElementById('applyTimeFilter').style.display = 'inline';
                
                // Set default to last 24 hours
                const now = new Date();
                const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                const endDateValue = now.toISOString().slice(0, 16);
                const startDateValue = yesterday.toISOString().slice(0, 16);
                
                document.getElementById('endDateTime').value = endDateValue;
                document.getElementById('startDateTime').value = startDateValue;
                
                // Update global variables immediately
                startDateTime = startDateValue;
                endDateTime = endDateValue;
            }
            
            loadConnectionData();
        }
        
        // Apply time filter
        function applyTimeFilter() {
            startDateTime = document.getElementById('startDateTime').value;
            endDateTime = document.getElementById('endDateTime').value;
            
            // Update status to show loading
            document.getElementById('status').textContent = 'Applying time filter...';
            
            loadConnectionData();
        }
        
        // Generate and download CSV file
        function downloadConnectionsCSV() {
            try {
                // Use filtered data (respects current search and filters)
                const dataToExport = [...filteredData];
                
                if (dataToExport.length === 0) {
                    alert('No connections data to export');
                    return;
                }
                
                // CSV headers
                const headers = [
                    'IP Address',
                    'Hostname',
                    'Country',
                    'Country Code', 
                    'Region',
                    'City',
                    'ISP',
                    'Organization',
                    'ASN',
                    'Total Connections',
                    'Inbound Connections',
                    'Outbound Connections',
                    'Last Seen',
                    'Timezone',
                    'Latitude',
                    'Longitude',
                    'Connection Types',
                    'Directions'
                ];
                
                // Convert data to CSV rows
                const csvRows = [headers.join(',')];
                
                dataToExport.forEach(conn => {
                    const row = [
                        `"${conn.ip || ''}"`,
                        `"${(conn.hostname || 'No hostname found').replace(/"/g, '""')}"`,
                        `"${(conn.country || 'Unknown').replace(/"/g, '""')}"`,
                        `"${conn.countryCode || 'XX'}"`,
                        `"${(conn.region || 'Unknown').replace(/"/g, '""')}"`,
                        `"${(conn.city || 'Unknown').replace(/"/g, '""')}"`,
                        `"${(conn.isp || 'Unknown').replace(/"/g, '""')}"`,
                        `"${(conn.org || 'Unknown').replace(/"/g, '""')}"`,
                        `"${(conn.asn || 'Unknown').replace(/"/g, '""')}"`,
                        conn.connectionCount || 0,
                        conn.inboundCount || 0,
                        conn.outboundCount || 0,
                        `"${new Date(conn.lastSeen).toISOString()}"`,
                        `"${conn.timezone || 'Unknown'}"`,
                        conn.latitude || 0,
                        conn.longitude || 0,
                        `"${Array.isArray(conn.connectionTypes) ? conn.connectionTypes.join('; ') : (conn.connectionTypes || '')}"`,
                        `"${Array.isArray(conn.directions) ? conn.directions.join('; ') : (conn.directions || '')}"`
                    ];
                    csvRows.push(row.join(','));
                });
                
                // Create CSV content
                const csvContent = csvRows.join('\n');
                
                // Create filename with timestamp and mode
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const mode = timeMode === 'current' ? 'current' : 'historical';
                const filename = `firewalla-connections-${mode}-${timestamp}.csv`;
                
                // Create and download file
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                
                if (link.download !== undefined) {
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', filename);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Show success message
                    document.getElementById('status').textContent = `Downloaded ${dataToExport.length} connections to ${filename}`;
                    setTimeout(() => {
                        document.getElementById('status').textContent = `Loaded ${connectionsData.length} connections`;
                    }, 3000);
                }
            } catch (error) {
                console.error('Error generating CSV:', error);
                alert('Error generating CSV file: ' + error.message);
            }
        }
        
        // Initialize application
        function init() {
            initMap();
            loadConnections();
            
            // Show color legend by default (map view is active)
            document.getElementById('colorLegend').style.display = 'flex';
            
            // Set up refresh button
            document.getElementById('refreshBtn').addEventListener('click', refreshData);
            
            // Set up view switching buttons
            document.getElementById('mapViewBtn').addEventListener('click', () => switchView('map'));
            document.getElementById('listViewBtn').addEventListener('click', () => switchView('list'));
            
            // Set up direction filter buttons
            document.getElementById('directionBothBtn').addEventListener('click', () => setDirectionFilter('both'));
            document.getElementById('directionInboundBtn').addEventListener('click', () => setDirectionFilter('inbound'));
            document.getElementById('directionOutboundBtn').addEventListener('click', () => setDirectionFilter('outbound'));
            
            // Set up time mode filter buttons
            document.getElementById('timeCurrentBtn').addEventListener('click', () => setTimeMode('current'));
            document.getElementById('timeHistoryBtn').addEventListener('click', () => setTimeMode('history'));
            document.getElementById('applyTimeFilter').addEventListener('click', applyTimeFilter);
            
            // Set up search functionality
            document.getElementById('searchBox').addEventListener('input', (e) => {
                filterConnections(e.target.value);
            });
            
            // Set up CSV download button
            document.getElementById('downloadCsvBtn').addEventListener('click', downloadConnectionsCSV);
            
            // Set up pagination controls
            document.getElementById('pageSizeSelect').addEventListener('change', (e) => {
                pageSize = parseInt(e.target.value);
                currentPage = 1; // Reset to first page
                if (currentView === 'list') {
                    populateConnectionsTable();
                }
            });
            
            document.getElementById('firstPageBtn').addEventListener('click', () => goToPage(1));
            document.getElementById('prevPageBtn').addEventListener('click', () => goToPage(currentPage - 1));
            document.getElementById('nextPageBtn').addEventListener('click', () => goToPage(currentPage + 1));
            document.getElementById('lastPageBtn').addEventListener('click', () => goToPage(totalPages));
            
            document.getElementById('pageJumpInput').addEventListener('change', (e) => {
                const page = parseInt(e.target.value);
                if (!isNaN(page)) {
                    goToPage(page);
                }
            });
            
            // Set up sort buttons
            document.querySelectorAll('.sort-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const field = e.target.dataset.sort;
                    
                    // Toggle sort direction if same field
                    if (sortField === field) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortField = field;
                        sortDirection = 'asc';
                    }
                    
                    // Update button states
                    document.querySelectorAll('.sort-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Re-render table
                    updateTable();
                });
            });
            
            // Auto-refresh every 10 minutes
            setInterval(loadConnections, 10 * 60 * 1000);
        }
        
        // Start when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>